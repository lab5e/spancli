package cert

import (
	"encoding/pem"
	"errors"
	"fmt"
	"io"
	"os"
	"text/template"
)

type convertCert struct {
	CertFile string `long:"cert" required:"yes" description:"cert file, PEM encoded"`
	KeyFile  string `long:"key" required:"yes" description:"key file, PEM encoded"`
}

func (cc *convertCert) Usage() string {
	return `Convert a certificate into C-style byte buffers

	Ouput is an include file with three declared byte buffers:
		- pem_ca - intermediates and root CA
		- pem_client - client certificate
		- pem_key - client certificate key

	This is suitable for libcoap with PEM encoded inputs.
	`
}
func (cc *convertCert) Execute([]string) error {
	certBuf, err := os.ReadFile(cc.CertFile)
	if err != nil {
		return err
	}
	keyBuf, err := os.ReadFile(cc.KeyFile)
	if err != nil {
		return err
	}

	return formatOutput(os.Stdout, certBuf, keyBuf)
}

func formatOutput(writer io.Writer, cert []byte, key []byte) error {
	tmpl, err := template.New("header").Parse(headerTemplate)
	if err != nil {
		return err
	}

	// Split the client cert and chain into separate byte buffers
	var blocks [][]byte
	block, rest := pem.Decode(cert)
	for block != nil {
		blocks = append(blocks, toPEM(block))
		block, rest = pem.Decode(rest)
	}
	if len(blocks) < 2 {
		return errors.New("no PEM block found in certificate file")
	}
	caBlocks := blocks[len(blocks)-1]
	var chainBlocks []byte
	for i := 1; i < len(blocks)-1; i++ {
		chainBlocks = append(chainBlocks, blocks[i]...)
	}
	if err := tmpl.Execute(writer, headerData{
		CA:         cArray(caBlocks),
		Chain:      cArray(chainBlocks),
		ClientCert: cArray(blocks[0]),
		ClientKey:  cArray(key),
	}); err != nil {
		return err
	}
	return nil
}

func toPEM(block *pem.Block) []byte {
	return pem.EncodeToMemory(block)
}

func cArray(buf []byte) string {
	ret := ""
	for i, ch := range buf {
		if i%10 == 0 {
			ret += "\n    "
		}
		ret += fmt.Sprintf("0x%02x, ", ch)
	}
	// Add 0-termination
	ret += "\n    0x00"
	return ret
}

type headerData struct {
	CA         string
	ClientCert string
	ClientKey  string
	Chain      string
}

const headerTemplate = `
/** 
 * This file is autogenerated by the Span CLI. 
 */
#pragma once
#include <stdint.h>

// This is the PEM-encoded root certificate
const uint8_t pem_ca[] = { {{ .CA }} };

// This is the PEM-encoded intermediate certificates 
const uint8_t pem_chain[] = { {{ .Chain }} };

// This is the PEM-encoded client certificate
const uint8_t pem_client[] = { {{ .ClientCert }} };

// This is the PEM-encoded client private key
const uint8_t pem_key[] = { {{ .ClientKey }} };
`
